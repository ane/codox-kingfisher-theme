= User Guide
Antoine Kalmbach
v0.1.0
:toc: left
:numbered:
:idseparator: -
:idprefix:
:sectlinks:

This is the official Task user guide.

[[creating-tasks]]
Creating tasks
~~~~~~~~~~~~~~

To create a task, use [[run]]. It evaluates its result asynchronously.
It behaves more or less like http://clojuredocs.org/clojure.core/do[do]
except that it, depending on the
https://ane.github.io/task/03-executors.html[execution model], may
evaluate its result in another thread.

[source,clojure]
----
(task/run (println "hello")
          (Thread/sleep 1000)
          123)
----

This task evaluates to 123. We can get it value by `deref`ing it.

To get the value of the task, use `deref` or `@` from the Clojure
standard library. This blocks the current thread.

[source,clojure]
----
; these are both equal
@(task/run 123) ; => 123

(deref (task/run 123)) ; => 123
----

_See the docs on http://clojuredocs.org/clojure.core/deref[deref]._

Note, that calling `(run 123)` results possibly in the creation of
another thread. To create an "immeadiate" value that doesn't cause any
unwanted execution, use `now`:

[source,clojure]
----
@(task/now 123)
----

To create an empty task you can use `(void)` which is a task that never
completes.

If you want to use another executor, use `run-in`:

[source,clojure]
----
(let [pool (Executors/newFixedThreadPool 16)]
  (task/run-in pool
    (Thread/sleep 1000)
    123)
----

[[composing-tasks]]
Composing tasks
~~~~~~~~~~~~~~~

[[function-application-then]]
Function application: `then`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you want to apply a function on the value returned by a task, use
`then`:

[source,clojure]
----
(task/then clojure.string/upper-case (task/run "asdf"))
; => ASDF
----

`then` produces another task, so you can deref its result:

[source,clojure]
----
@(task/then inc (task/run 123))

; => 124
----

If you want to apply a function that produces another task, use
`compose`:

[source,clojure]
----
@(task/compose (fn [x] (task/run
                         (Thread/sleep 1212)
                         (inc x)))
               (task/run 778))
----

If you had used `then` the result would have been a task inside another
task.

[[interoperability]]
Interoperability
~~~~~~~~~~~~~~~~

Standard Clojure `future` and `promise` are compatible with tasks:

[source,clojure]
----
@(then inc (future 9)) ; => 10

(def foo (promise))

(then println foo)

(deliver foo "hello")

; prints "hello"
----

[[using-executors]]
Using executors
~~~~~~~~~~~~~~~

Both `then` and `compose` accept a third parameter as the
https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html[ExecutorService]:

[source,clojure]
----
(let [pool (Executors/newFixedThreadPool 4)]
  (task/then inc (task/run 123) pool))
----

[[using-for-to-avoid-boilerplate]]
Using `for` to avoid boilerplate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The [[for]] macro, like its standard library namesake, lets you skip
some boilerplate when working with tasks that depend on each other:

[source,clojure]
----
(task/for [x (task/run 123)
           y (future 123)
           z (task/run (Thread/sleep 1000) 4)]
  (+ x y z))
----

`for` evaluates its body once all futures are complete, and the values
of each future are bound to their respective bindings.

[[lists-of-tasks]]
Lists of tasks
--------------

If you have a sequence of tasks, and you want to deal with each result
as a whole, you can turn a sequence of tasks into a task that evaluates
into the values of each task inside it using [[sequence]]:

[source,clojure]
----
@(task/sequence [(task/run 123) (future 9) (task/run (Thread/sleep 100) "hello")])

; => [123 9 "hello"]
----

`sequence` completes when all the tasks complete.

[[completion]]
Completion
^^^^^^^^^^

To check if a task is complete, use [[done?]]:

[source,clojure]
----
(task/done? some-task)

(task/done? (task/run (Thread/sleep 123123) 'foo))
; => false

(task/done? (task/now 1))
----

To complete a task before it is done, use [[complete!]]:

[source,clojure]
----
(def baz (task/run (Thread/sleep 10000) 'foo))

(task/complete! baz 'bar)

@baz ; => 'bar
----

If the task is already complete, it does nothing.

To get a value anyway if the task isn't complete, use [[else]]:

[source,clojure]
----
(else (task/run (Thread/sleep 1000) 1) 2)

; => 2
----

[[forcing-a-result]]
Forcing a result
----------------

To force the result of a task, completed or not, use [[force!]]:

[source,clojure]
----
(def t (task/now 123))

(task/force! t 'hi)

@t ; => 'hi
----

[[cancellation]]
Cancellation
^^^^^^^^^^^^

To cancel a task, use [[cancel]]:

[source,clojure]
----
(def my-task (task/run (Thread/sleep 10000) 'bla))

(task/cancel my-task)
----

To see if the task was cancelled, use [[cancelled?]]:

[source,clojure]
----
(cancelled? my-task) ; => true
----

Using `deref` on a cancelled task blows up, predictably.

[[failures]]
Failures
^^^^^^^^

A task is said to have _failed_ if its evaluation produced an exception
or it produced an exception during its execution. Such a task is a
cancelled task (see link:#Cancellation[Cancellation]), or any task that
produces an exception when `deref`'d:

[source,clojure]
----
(def oops (task/run (throw (RuntimeException. "hey!"))))

@oops

; RuntimeException hey!  task.core/fn--17494 (form-init7142405608168193525.clj:182)
----

[[failed? ]]will tell you if that task has failed:

[source,clojure]
----
(task/failed? oops) ; => true
----

To create a failed task with some exception, use [[failed]]:

[source,clojure]
----
(def failed-task (task/failed (RuntimeException. "argf")))
----

To get the exception that caused the failure, use [[failure]]:

[source,clojure]
----
(task/failure failed-task) ; => RuntimeException[:cause "argf"] 
----

To force a task to fail, like [[force!]], use [[fail!]]:

[source,clojure]
----
(def foo (task/now "hi there"))

(task/fail! foo (IllegalStateException. "poop"))

(task/failed? foo) ; => true

(task/failure foo) ; => IllegalStateException[:cause "poop"]
----

Chaining a failed task to a normal task will cause the resulting task to
fail.

[[recovering-from-errors]]
Recovering from errors
----------------------

To recover from errors, use [[recover]]:

[source,clojure]
----
(def boom (task/run (/ 1 0)))

(def incremented (task/then inc boom))
----

This will blow up, so we can ensure that the resulting operation
succeeds:

[source,clojure]
----
@(recover incremented
          (fn [ex]
            (println "caught exception: " (.getMessage ex))
            123))

; caught exception: java.lang.ArithmeticException: Divide by zero
; => 123
----

So you can recover from potential failures using a backup value from the
function. Supplying a non-function will just recover with that value:

[source,clojure]
----
@(recover boom "hello") ; => "hello"
----
